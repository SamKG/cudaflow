use crate::cuda_hook;
use cust_raw::driver_sys::{
    CUdriverProcAddressQueryResult, CUresult, cudaError_enum::CUDA_SUCCESS, cuuint64_t,
};
use std::{
    ffi::CStr,
    os::raw::{c_char, c_int, c_void},
};
use tracing::debug;

// Map generated by build.rs
fn get_hooked_symbol(name: &str) -> Option<*mut c_void> {
    include!(concat!(env!("OUT_DIR"), "/hook_map.rs"))
}

cuda_hook! {
    pub unsafe extern "C" fn cuGetProcAddress_v2(
        symbol: *const c_char,
        pfn: *mut *mut c_void,
        cudaVersion: c_int,
        flags: cuuint64_t,
        symbolStatus: *mut CUdriverProcAddressQueryResult,
    ) -> CUresult {
        debug!("cuGetProcAddress_v2 called for symbol: {:?}", unsafe{CStr::from_ptr(symbol)});
        // 1. Call real implementation first
        let real_fn = *__real_cuGetProcAddress_v2;
        let ret = unsafe{real_fn(symbol, pfn, cudaVersion, flags, symbolStatus)};

        // 2. Intercept result and overwrite if we hook this function
        let name = unsafe{CStr::from_ptr(symbol)}.to_string_lossy();
        if let Some(our_ptr) = get_hooked_symbol(&name) {
            debug!("Hooking procAddr: {}", name);
            unsafe{*pfn = our_ptr};
            return CUDA_SUCCESS;
        }

        ret
    }
}

// Trampoline v1 -> v2
cuda_hook! {
    pub unsafe extern "C" fn cuGetProcAddress(
        symbol: *const c_char,
        pfn: *mut *mut c_void,
        cudaVersion: c_int,
        flags: cuuint64_t,
        symbolStatus: *mut CUdriverProcAddressQueryResult,
    ) -> CUresult {
        debug!("cuGetProcAddress called for symbol: {:?}", unsafe{CStr::from_ptr(symbol)});
        // 1. Call real implementation first
        let real_fn = *__real_cuGetProcAddress;
        let ret = unsafe{real_fn(symbol, pfn, cudaVersion, flags, symbolStatus)};

        // 2. Intercept result and overwrite if we hook this function
        let name = unsafe{CStr::from_ptr(symbol)}.to_string_lossy();
        if let Some(our_ptr) = get_hooked_symbol(&name) {
            debug!("Hooking procAddr: {}", name);
            unsafe{*pfn = our_ptr};
            return CUDA_SUCCESS;
        }

        ret
    }
}
